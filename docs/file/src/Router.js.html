<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/Router.js | Backbone-ES6 API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/typhonjs/backbone-es6/" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Backbone.js~Backbone.html">Backbone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Collection.js~Collection.html">Collection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Debug.js~Debug.html">Debug</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Events.js~Events.html">Events</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/History.js~History.html">History</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Router.js~Router.html">Router</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Utils.js~Utils.html">Utils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/View.js~View.html">View</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extend">extend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sync">sync</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BackboneProxy">BackboneProxy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-collection">collection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-model">model</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Router.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

import _             from &apos;underscore&apos;;
import BackboneProxy from &apos;./BackboneProxy.js&apos;;
import Events        from &apos;./Events.js&apos;;

// Private / internal methods ---------------------------------------------------------------------------------------

/**
 * Cached regular expressions for matching named param parts and splatted parts of route strings.
 * @type {RegExp}
 */
const s_ESCAPE_REGEX = /[\-{}\[\]+?.,\\\^$|#\s]/g;
const s_NAMED_PARAM = /(\(\?)?:\w+/g;
const s_OPTIONAL_PARAM = /\((.*?)\)/g;
const s_SPLAT_PARAM = /\*\w+/g;

/**
 * Bind all defined routes to `Backbone.history`. We have to reverse the order of the routes here to support behavior
 * where the most general routes can be defined at the bottom of the route map.
 *
 * @param {Router}   router   - Instance of `Backbone.Router`.
 */
const s_BIND_ROUTES = (router) =&gt;
{
   if (!router.routes) { return; }

   router.routes = _.result(router, &apos;routes&apos;);

   _.each(_.keys(router.routes), (route) =&gt;
   {
      router.route(route, router.routes[route]);
   });
};

/**
 * Given a route, and a URL fragment that it matches, return the array of extracted decoded parameters. Empty or
 * unmatched parameters will be treated as `null` to normalize cross-browser behavior.
 *
 * @param {string}   route - A route string or regex.
 * @param {string}   fragment - URL fragment.
 * @returns {*}
 */
const s_EXTRACT_PARAMETERS = (route, fragment) =&gt;
{
   const params = route.exec(fragment).slice(1);

   return _.map(params, (param, i) =&gt;
   {
      // Don&apos;t decode the search params.
      if (i === params.length - 1) { return param || null; }
      return param ? decodeURIComponent(param) : null;
   });
};

/**
 * Convert a route string into a regular expression, suitable for matching against the current location hash.
 *
 * @param {string}   route - A route string or regex.
 * @returns {RegExp}
 */
const s_ROUTE_TO_REGEX = (route) =&gt;
{
   route = route.replace(s_ESCAPE_REGEX, &apos;\\$&amp;&apos;)
    .replace(s_OPTIONAL_PARAM, &apos;(?:$1)?&apos;)
    .replace(s_NAMED_PARAM, (match, optional) =&gt;
    {
       return optional ? match : &apos;([^/?]+)&apos;;
    })
    .replace(s_SPLAT_PARAM, &apos;([^?]*?)&apos;);
   return new RegExp(`^${route}(?:\\?([\\s\\S]*))?$`);
};

/**
 * Backbone.Router - Provides methods for routing client-side pages, and connecting them to actions and events.
 * (http://backbonejs.org/#Router)
 * ---------------
 * Web applications often provide linkable, bookmarkable, shareable URLs for important locations in the app. Until
 * recently, hash fragments (#page) were used to provide these permalinks, but with the arrival of the History API,
 * it&apos;s now possible to use standard URLs (/page). Backbone.Router provides methods for routing client-side pages, and
 * connecting them to actions and events. For browsers which don&apos;t yet support the History API, the Router handles
 * graceful fallback and transparent translation to the fragment version of the URL.
 *
 * During page load, after your application has finished creating all of its routers, be sure to call
 * Backbone.history.start() or Backbone.history.start({pushState: true}) to route the initial URL.
 *
 * routes - router.routes
 * The routes hash maps URLs with parameters to functions on your router (or just direct function definitions, if you
 * prefer), similar to the View&apos;s events hash. Routes can contain parameter parts, :param, which match a single URL
 * component between slashes; and splat parts *splat, which can match any number of URL components. Part of a route can
 * be made optional by surrounding it in parentheses (/:optional).
 *
 * For example, a route of &quot;search/:query/p:page&quot; will match a fragment of #search/obama/p2, passing &quot;obama&quot; and &quot;2&quot; to
 * the action.
 *
 * A route of &quot;file/*path&quot; will match #file/nested/folder/file.txt, passing &quot;nested/folder/file.txt&quot; to the action.
 *
 * A route of &quot;docs/:section(/:subsection)&quot; will match #docs/faq and #docs/faq/installing, passing &quot;faq&quot; to the action
 * in the first case, and passing &quot;faq&quot; and &quot;installing&quot; to the action in the second.
 *
 * Trailing slashes are treated as part of the URL, and (correctly) treated as a unique route when accessed. docs and
 * docs/ will fire different callbacks. If you can&apos;t avoid generating both types of URLs, you can define a &quot;docs(/)&quot;
 * matcher to capture both cases.
 *
 * When the visitor presses the back button, or enters a URL, and a particular route is matched, the name of the action
 * will be fired as an event, so that other objects can listen to the router, and be notified. In the following example,
 * visiting #help/uploading will fire a route:help event from the router.
 *
 * @example
 * routes: {
 *    &quot;help/:page&quot;:         &quot;help&quot;,
 *    &quot;download/*path&quot;:     &quot;download&quot;,
 *    &quot;folder/:name&quot;:       &quot;openFolder&quot;,
 *    &quot;folder/:name-:mode&quot;: &quot;openFolder&quot;
 * }
 *
 * router.on(&quot;route:help&quot;, function(page) {
 *    ...
 * });
 *
 * @example
 * Old extend - Backbone.Router.extend(properties, [classProperties])
 * Get started by creating a custom router class. Define actions that are triggered when certain URL fragments are
 * matched, and provide a routes hash that pairs routes to actions. Note that you&apos;ll want to avoid using a leading
 * slash in your route definitions:
 *
 * var Workspace = Backbone.Router.extend({
 *    routes: {
 *       &quot;help&quot;:                 &quot;help&quot;,    // #help
 *       &quot;search/:query&quot;:        &quot;search&quot;,  // #search/kiwis
 *       &quot;search/:query/p:page&quot;: &quot;search&quot;   // #search/kiwis/p7
 *    },
 *
 *    help: function() {
 *       ...
 *    },
 *
 *    search: function(query, page) {
 *       ...
 *    }
 * });
 *
 * @example
 * Converting the above example to ES6 using a getter method for `routes`:
 * class Workspace extends Backbone.Router {
 *    get routes() {
 *       return {
 *          &quot;help&quot;:                 &quot;help&quot;,    // #help
 *          &quot;search/:query&quot;:        &quot;search&quot;,  // #search/kiwis
 *          &quot;search/:query/p:page&quot;: &quot;search&quot;   // #search/kiwis/p7
 *       };
 *    }
 *
 *    help() {
 *       ...
 *    },
 *
 *    search(query, page) {
 *       ...
 *    }
 * }
 *
 * @example
 * Basic default &quot;no route router&quot;:
 * new Backbone.Router({ routes: { &apos;*actions&apos;: &apos;defaultRoute&apos; } });
 */
export default class Router extends Events
{
   /**
    * When creating a new router, you may pass its routes hash directly as an option, if you choose. All options will
    * also be passed to your initialize function, if defined.
    *
    * @see http://backbonejs.org/#Router-constructor
    *
    * @param {object}   options  - Optional parameters which may contain a &quot;routes&quot; object literal.
    */
   constructor(options = {})
   {
      super();

      // Must detect if there are any getters defined in order to skip setting this value.
      const hasRoutesGetter = !_.isUndefined(this.routes);

      if (!hasRoutesGetter &amp;&amp; options.routes)
      {
         /**
          * Stores the routes hash.
          * @type {object}
          */
         this.routes = options.routes;
      }

      s_BIND_ROUTES(this);

      this.initialize(...arguments);
   }

   /* eslint-disable no-unused-vars */
   /**
    * Execute a route handler with the provided parameters.  This is an excellent place to do pre-route setup or
    * post-route cleanup.
    *
    * @see http://backbonejs.org/#Router-execute
    *
    * @param {function} callback - Callback function to execute.
    * @param {*[]}      args     - Arguments to apply to callback.
    * @param {string}   name     - Named route.
    */
   execute(callback, args, name)
   {
      /* eslint-enable no-unused-vars */
      if (callback) { callback.apply(this, args); }
   }

   /**
    * Initialize is an empty function by default. Override it with your own initialization logic.
    *
    * @see http://backbonejs.org/#Router-constructor
    * @abstract
    */
   initialize()
   {
   }

   /**
    * Simple proxy to `Backbone.history` to save a fragment into the history.
    *
    * @see http://backbonejs.org/#Router-navigate
    * @see History
    *
    * @param {string}   fragment - String representing an URL fragment.
    * @param {object}   options - Optional hash containing parameters for navigate.
    * @returns {Router}
    */
   navigate(fragment, options)
   {
      BackboneProxy.backbone.history.navigate(fragment, options);
      return this;
   }

   /**
    * Manually bind a single named route to a callback. For example:
    *
    * @example
    * this.route(&apos;search/:query/p:num&apos;, &apos;search&apos;, function(query, num)
    * {
    *    ...
    * });
    *
    * @see http://backbonejs.org/#Router-route
    *
    * @param {string|RegExp}  route    -  A route string or regex.
    * @param {string}         name     -  A name for the route.
    * @param {function}       callback -  A function to invoke when the route is matched.
    * @returns {Router}
    */
   route(route, name, callback)
   {
      if (!_.isRegExp(route)) { route = s_ROUTE_TO_REGEX(route); }
      if (_.isFunction(name))
      {
         callback = name;
         name = &apos;&apos;;
      }
      if (!callback) { callback = this[name]; }

      BackboneProxy.backbone.history.route(route, (fragment) =&gt;
      {
         const args = s_EXTRACT_PARAMETERS(route, fragment);

         if (this.execute(callback, args, name) !== false)
         {
            this.trigger(...([`route:${name}`].concat(args)));
            this.trigger(&apos;route&apos;, name, args);
            BackboneProxy.backbone.history.trigger(&apos;route&apos;, this, name, args);
         }
      });

      return this;
   }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.1)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
